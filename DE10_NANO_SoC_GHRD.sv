//=======================================================
//  This code *was, at some time, * generated by Terasic System Builder
//=======================================================

module DE10_NANO_SoC_GHRD(

    //////////// CLOCK //////////
    input logic              FPGA_CLK1_50,
    input logic              FPGA_CLK2_50,
    input logic              FPGA_CLK3_50,

    //////////// HPS //////////
    output logic  [14: 0]    HPS_DDR3_ADDR,
    output logic  [ 2: 0]    HPS_DDR3_BA,
    output logic             HPS_DDR3_CAS_N,
    output logic             HPS_DDR3_CK_N,
    output logic             HPS_DDR3_CK_P,
    output logic             HPS_DDR3_CKE,
    output logic             HPS_DDR3_CS_N,
    output logic  [ 3: 0]    HPS_DDR3_DM,
    inout  logic  [31: 0]    HPS_DDR3_DQ,
    inout  logic  [ 3: 0]    HPS_DDR3_DQS_N,
    inout  logic  [ 3: 0]    HPS_DDR3_DQS_P,
    output logic             HPS_DDR3_ODT,
    output logic             HPS_DDR3_RAS_N,
    output logic             HPS_DDR3_RESET_N,
    input  logic             HPS_DDR3_RZQ,
    output logic             HPS_DDR3_WE_N,

    //////////// GPIO //////////
    inout  logic  [35:0]     GPIO_D,

    //////////// LED //////////
    output logic  [ 7: 0]    LED,

    //////////// SWITCHES //////////
    input  logic  [ 3: 0]    SW,
     
    //////////// SWITCHES //////////
    input  logic  [ 1: 0]    KEY
);

//=======================================================
//  reg/wire declarations
//=======================================================
logic hps_fpga_reset_n;
logic fpga_clk_50;

//=======================================================
//  RAM variables
//=======================================================
logic [21:0] address = 16'd0;
logic read = 1'b0;
logic write = 1'b0;
logic acknowledge;
logic [31:0] read_data = 32'd0;
logic [31:0] write_data = 32'd0;
logic [3:0] byte_enable = 4'b1111;

//=======================================================
//  UART variables
//=======================================================
logic [7:0] uart_wdata;
logic uart_write;
logic uart_in_error;
logic uart_in_ready;

logic [7:0] uart_rdata;
logic uart_out_ready;
logic uart_out_error;
logic uart_out_valid;
logic [31:0] GPIOS = 0;

// connection of internal logics
assign fpga_clk_50 = FPGA_CLK1_50;
assign GPIO_D[34:3] = GPIOS;

//=======================================================
//  Structural coding
//=======================================================
soc_system u_u0(
    //Clock&Resetread_data[6:0]
    .clk_clk(FPGA_CLK1_50),                                      //                            clk.clk
    .reset_reset_n(hps_fpga_reset_n),                            //                          reset.reset_n
    //HPS ddr3
    .memory_mem_a(HPS_DDR3_ADDR),                                //                         memory.mem_a
    .memory_mem_ba(HPS_DDR3_BA),                                 //                               .mem_ba
    .memory_mem_ck(HPS_DDR3_CK_P),                               //                               .mem_ck
    .memory_mem_ck_n(HPS_DDR3_CK_N),                             //                               .mem_ck_n
    .memory_mem_cke(HPS_DDR3_CKE),                               //                               .mem_cke
    .memory_mem_cs_n(HPS_DDR3_CS_N),                             //                               .mem_cs_n
    .memory_mem_ras_n(HPS_DDR3_RAS_N),                           //                               .mem_ras_n
    .memory_mem_cas_n(HPS_DDR3_CAS_N),                           //                               .mem_cas_n
    .memory_mem_we_n(HPS_DDR3_WE_N),                             //                               .mem_we_n
    .memory_mem_reset_n(HPS_DDR3_RESET_N),                       //                               .mem_reset_n
    .memory_mem_dq(HPS_DDR3_DQ),                                 //                               .mem_dq
    .memory_mem_dqs(HPS_DDR3_DQS_P),                             //                               .mem_dqs
    .memory_mem_dqs_n(HPS_DDR3_DQS_N),                           //                               .mem_dqs_n
    .memory_mem_odt(HPS_DDR3_ODT),                               //                               .mem_odt
    .memory_mem_dm(HPS_DDR3_DM),                                 //                               .mem_dm
    .memory_oct_rzqin(HPS_DDR3_RZQ),                             //                               .oct_rzqin

    .hps_0_h2f_reset_reset_n(hps_fpga_reset_n),                  //                hps_0_h2f_reset.reset_n
    .sdram_address(address),
    .sdram_byte_enable(byte_enable),                             //                .byte_enable
    .sdram_read(read),              //                .read
    .sdram_write(write),             //                .write
    .sdram_write_data(write_data),        //                .write_data
    .sdram_acknowledge(acknowledge),       //                .acknowledge
    .sdram_read_data(read_data),

    .uart_RXD(GPIO_D[0]), // uart_0_external_connection.rxd
    .uart_TXD(GPIO_D[1]), //                           .txd

    .uart_in_data(uart_wdata),
    .uart_in_error(uart_in_error),
    .uart_in_valid(uart_write),
    .uart_in_ready(uart_in_ready),

    .uart_out_ready(uart_out_ready),
    .uart_out_data(uart_rdata),
    .uart_out_error(uart_out_error),
    .uart_out_valid(uart_out_valid)
);

//=======================================================
//  Memory read/write finite automata
//=======================================================

enum int unsigned {
    MEM_STATE_INIT = 1,
    MEM_STATE_READ_PENDING = 2,
    MEM_STATE_WRITE_PENDING = 3
} cur_mem_state, next_mem_state;

logic read_req  = 0;
logic write_req = 0;

// State switch logic
always_comb begin
    next_mem_state = cur_mem_state;
    case (cur_mem_state)
        MEM_STATE_INIT: begin
            if (read_req) next_mem_state = MEM_STATE_READ_PENDING;
            else if (write_req) next_mem_state = MEM_STATE_WRITE_PENDING;
        end

        MEM_STATE_READ_PENDING: begin
            if (acknowledge) next_mem_state = MEM_STATE_INIT;
        end

        MEM_STATE_WRITE_PENDING: begin
            if (acknowledge) next_mem_state = MEM_STATE_INIT;
        end

        default: begin
            next_mem_state = MEM_STATE_INIT;
        end
    endcase
end

always_comb begin
    read = 0;
    write = 0;

    case (cur_mem_state)
        MEM_STATE_READ_PENDING: begin
            read = 1;
        end

        MEM_STATE_WRITE_PENDING: begin
            write = 1;
        end

        default: begin
        end
    endcase
end

//=======================================================
//  CPU state enum and regs / wires
//=======================================================
enum int unsigned {
    CPU_STATE_INSTR_FETCH              = 1,
    CPU_STATE_INSTR_FETCH_1            = 2,
    CPU_STATE_INSTR_DECODE             = 3,
    CPU_STATE_INSTR_DECODE_1           = 4,
    CPU_STATE_INSTR_IMM_FETCH          = 5,
    CPU_STATE_INSTR_IMM_FETCH_1        = 6,
    CPU_STATE_INSTR_SECOND_IMM_FETCH   = 7,
    CPU_STATE_INSTR_SECOND_IMM_FETCH_1 = 8,
    CPU_STATE_INSTR_OPERAND_FETCH      = 9,
    CPU_STATE_INSTR_OPERAND_FETCH_1    = 10,
    CPU_STATE_INSTR_EXEC               = 11,
    CPU_STATE_INSTR_EXEC_1             = 12,
    CPU_STATE_INSTR_WRITEBACK          = 13,
    CPU_STATE_INSTR_WRITEBACK_1        = 14
} cur_cpu_state;

//=======================================================
//  CPU single-step button setup.
//=======================================================

// Cpu single-step clock setup
// If a SW[3] is set to 1,
// then the cpu cycles by pressing KEY[1]
logic [1:0] debounced_keys = 2'd0;
debounce #(2, "LOW", 50000, 16) debouncer(
    .clk(fpga_clk_50),
    .reset_n(hps_fpga_reset_n),
    .data_in(KEY),
    .data_out(debounced_keys)
);

reg   is_halted    = 0;
reg   cycle_done   = 1;
reg   prev_pressed = 0;

//=======================================================
//  CPU instruction decoder / registers
//=======================================================

parameter MEM_STACK_BASE = 16'h4000;

// Registers, visible to users
reg [15:0] PC = 16'd0;
reg [15:0] FR = 16'd0;
reg [15:0] SP  = MEM_STACK_BASE;
reg [15:0] R00 = 0;
reg [15:0] R01 = 0;
reg [15:0] R02 = 0;
reg [15:0] R03 = 0;

// CPU variables
reg [39:0]  cur_instruction = 39'd0;
reg [2:0]  instr_reg_1 = 3'd0;
reg [2:0]  instr_reg_2 = 3'd0;

reg [31:0] data = 32'd0;
reg [15:0] tmp_address = 16'd0;
reg [15:0] tmp_word = 16'd0;
reg [15:0] cur_imm = 16'd0;
reg [15:0] snd_imm = 16'd0;
assign LED[7: 0] = PC[7:0];

//=======================================================
//  UART I/O variables and logic
//=======================================================
logic uart_write_req = 0;
logic uart_read_req = 0;
logic [7:0] uart_data = 0;

always_ff @(posedge fpga_clk_50 or negedge hps_fpga_reset_n) begin
if (~hps_fpga_reset_n) begin


cur_mem_state <= MEM_STATE_INIT;
cur_cpu_state <= CPU_STATE_INSTR_FETCH;
cycle_done <= 1;

read_req <= '0;
write_req <= '0;
prev_pressed <= debounced_keys[1];

cur_instruction <= 6'd0;
PC <= '0;
FR <= 16'd0;
SP <= MEM_STACK_BASE;
uart_out_ready <= '1;
uart_write <= '0;


end else begin


if (uart_out_valid) begin
    uart_data <= uart_rdata;
    uart_read_req <= 0;
    uart_out_ready <= 0;
    uart_write <= 0;
end

if (uart_write) begin
    uart_write_req <= 0;
    uart_out_ready <= 0;
    uart_write <= 0;
end

if (uart_write_req & uart_in_ready & ~uart_out_valid & ~uart_write) begin
    uart_out_ready <= 0;
    uart_write <= 1;
end else if (uart_read_req & ~uart_out_valid) begin
    uart_out_ready <= 1;
    uart_write <= 0;
end 

// Lotsa logic, sorry
cur_mem_state <= next_mem_state;

if (~debounced_keys[0]) is_halted <= 0;
if (~debounced_keys[0] & SW[1]) begin
    SP <= MEM_STACK_BASE;
    PC <= '0;
end

prev_pressed <= debounced_keys[1];
case (cur_mem_state)
    MEM_STATE_INIT: begin
    end

    MEM_STATE_READ_PENDING: begin
        if (acknowledge) data <= read_data;
        read_req <= 0;
        write_req <= 0;
    end

    MEM_STATE_WRITE_PENDING: begin
        read_req <= 0;
        write_req <= 0;
    end

    default: begin
        read_req <= 0;
        write_req <= 0;
    end
endcase

//=======================================================
//  The instruction decoder itself. Finally )
//=======================================================
if (
    ~SW[1] & // If SW[1] is on, we wait for button 0 to set PC to 0
    cur_mem_state == MEM_STATE_INIT & ~is_halted & // Only do cpu stuff when memory is not read/written to
    ~read_req & ~write_req & // Same as line one
    ~uart_write_req &  ~uart_read_req &// Can't do UART either (
    (~SW[3] | (prev_pressed & ~debounced_keys[1] & cycle_done) | ~cycle_done) // Button checker
    ) begin
    cycle_done <= cur_cpu_state == CPU_STATE_INSTR_WRITEBACK_1;

    case (cur_cpu_state)
        CPU_STATE_INSTR_FETCH: begin
            cur_cpu_state <= CPU_STATE_INSTR_FETCH_1;
        end

        CPU_STATE_INSTR_FETCH_1: begin
            cur_cpu_state <= CPU_STATE_INSTR_DECODE;
        end

        CPU_STATE_INSTR_DECODE: begin
            cur_cpu_state <= CPU_STATE_INSTR_DECODE_1;
        end

        CPU_STATE_INSTR_DECODE_1: begin
            cur_cpu_state <= CPU_STATE_INSTR_IMM_FETCH;
        end

        CPU_STATE_INSTR_IMM_FETCH: begin
            cur_cpu_state <= CPU_STATE_INSTR_IMM_FETCH_1;
        end

        CPU_STATE_INSTR_IMM_FETCH_1: begin
            cur_cpu_state <= CPU_STATE_INSTR_SECOND_IMM_FETCH;
        end

        CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
            cur_cpu_state <= CPU_STATE_INSTR_SECOND_IMM_FETCH_1;
        end

        CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
            cur_cpu_state <= CPU_STATE_INSTR_OPERAND_FETCH;
        end

        CPU_STATE_INSTR_OPERAND_FETCH: begin
            cur_cpu_state <= CPU_STATE_INSTR_OPERAND_FETCH_1;
        end

        CPU_STATE_INSTR_OPERAND_FETCH_1: begin
            cur_cpu_state <= CPU_STATE_INSTR_EXEC;
        end

        CPU_STATE_INSTR_EXEC: begin
            cur_cpu_state <= CPU_STATE_INSTR_EXEC_1;
        end

        CPU_STATE_INSTR_EXEC_1: begin
            cur_cpu_state <= CPU_STATE_INSTR_WRITEBACK;
        end

        CPU_STATE_INSTR_WRITEBACK: begin
            cur_cpu_state <= CPU_STATE_INSTR_WRITEBACK_1;
        end

        CPU_STATE_INSTR_WRITEBACK_1: begin
            cur_cpu_state <= CPU_STATE_INSTR_FETCH;
        end

        default: begin
            cur_cpu_state <= CPU_STATE_INSTR_FETCH;
        end
    endcase

    if (cur_cpu_state == CPU_STATE_INSTR_FETCH) begin
        byte_enable <= 4'b1111;
        address <= {PC[15:2], 2'b00};
        read_req <= 1;
    end else if (cur_cpu_state == CPU_STATE_INSTR_FETCH_1) begin
        case (PC[1:0])
            2'b00: cur_instruction[31:0] <= data[31:0];
            2'b01: cur_instruction[23:0] <= data[31:8];
            2'b10: cur_instruction[15:0] <= data[31:16];
            2'b11: cur_instruction[ 7:0] <= data[31:24];
            default: begin
            end
        endcase
        byte_enable <= 4'b1111;
        address <= {PC[15:2], 2'b00} + 16'd4;
        read_req <= 1;
    end else  if (cur_cpu_state == CPU_STATE_INSTR_DECODE) begin
        case (PC[1:0])
            2'b00: cur_instruction[39:32] <= data[7:0];
            2'b01: cur_instruction[39:24] <= data[15:0];
            2'b10: cur_instruction[39:16] <= data[23:0];
            2'b11: cur_instruction[39: 8] <= data[31:0];
            default: begin
            end
        endcase
    end else begin
        case (cur_instruction[5:0])
            // Radomyr's part
            // That's a NOP )
            default: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        PC <= PC + 16'd1;
                    end

                    default: begin
                    end
                endcase
            end

            // HALT
            6'b0: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        is_halted <= '1;
                        PC <= PC + 16'd1;
                    end

                    default: begin
                    end
                endcase
            end
				
            // LOAD %REG1, [%REG2]
            6'b000001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[8:6];
                        instr_reg_2 <= cur_instruction[11:9];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: begin
                                address <= {R00[15:2], 2'b00};
                                tmp_address <= R00;
                            end
                            3'b001: begin
                                address <= {R01[15:2], 2'b00};
                                tmp_address <= R01;
                            end
                            3'b010: begin
                                address <= {R02[15:2], 2'b00};
                                tmp_address <= R02;
                            end
                            3'b011: begin
                                address <= {R03[15:2], 2'b00};
                                tmp_address <= R03;
                            end

                            3'b100: begin
                                address <= {SP[15:2], 2'b00};
                                tmp_address <= SP;
                            end

                            default: begin
                            end
                        endcase

                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        case (instr_reg_1)
                            3'b000: R00 <= cur_imm;
                            3'b001: R01 <= cur_imm;
                            3'b010: R02 <= cur_imm;
                            3'b011: R03 <= cur_imm;
                            3'b100: SP <= {cur_imm[15:2], 2'b00};
                            3'b111: FR <= cur_imm;

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end
            
            // STORE [%REG1], %REG2
            6'b000010: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[8:6];
                        instr_reg_2 <= cur_instruction[11:9];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            3'b100: tmp_address <= SP;

                            default: begin
                            end
                        endcase

                        case (instr_reg_2)
                            3'b000: tmp_word <= R00;
                            3'b001: tmp_word <= R01;
                            3'b010: tmp_word <= R02;
                            3'b011: tmp_word <= R03;
                            3'b100: tmp_word <= SP;
                            3'b111: tmp_word <= FR;

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b1100;
                            end

                            2'b01: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b1000;
                            end
                            default: begin
                            end
                        endcase

                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                address <= {tmp_address[15:2], 2'b00};
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0100;
                                write_req <= 1;
                            end

                            2'b11: begin
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0001;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // MOV %REG, $IMM
            6'b000110: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[8:6];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (instr_reg_1) 
                            3'b000: R00 <= cur_imm;
                            3'b001: R01 <= cur_imm;
                            3'b010: R02 <= cur_imm;
                            3'b011: R03 <= cur_imm;
                            3'b100: SP <= {cur_imm[15:2], 2'b00};
                            3'b111: FR <= cur_imm;
                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // MOV %REG1, %REG2
            6'b0000101: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[8:6];
                        instr_reg_2 <= cur_instruction[11:9];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_word <= R00;
                            3'b001: tmp_word <= R01;
                            3'b010: tmp_word <= R02;
                            3'b011: tmp_word <= R03;
                            3'b100: tmp_word <= SP;
                            3'b111: tmp_word <= FR;

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: R00 <= tmp_word;
                            3'b001: R01 <= tmp_word;
                            3'b010: R02 <= tmp_word;
                            3'b011: R03 <= tmp_word;
                            3'b100: SP <= {tmp_word[15:2], 2'b00};
                            3'b111: FR <= tmp_word;

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end
            
            // PUSH %REG
            6'b101000: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_DECODE: begin
                        instr_reg_1 <= cur_instruction[8:6];
                        PC <= PC + 16'd2;
                        SP <= SP - 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: write_data <= {2{R00}};
                            3'b001: write_data <= {2{R01}};
                            3'b010: write_data <= {2{R02}};
                            3'b011: write_data <= {2{R03}};
                            3'b100: write_data <= {2{SP}};
                            3'b111: write_data <= {2{FR}};
                            default: begin
                            end
                        endcase
                        if (SP[1]) byte_enable <= 4'b1100;
                        else byte_enable <= 4'b0011;
                        address <= {SP[15:2], 2'b00};
                        write_req <= '1;
                    end

                    default: begin
                    end
                endcase
            end
            
            // POP %REG
            6'b101001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[8:6];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {SP[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        if (SP[1]) cur_imm <= data[31:16];
                        else cur_imm <= data[15:0];
                        SP <= SP + 16'd2;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: R00 <= cur_imm;
                            3'b001: R01 <= cur_imm;
                            3'b010: R02 <= cur_imm;
                            3'b011: R03 <= cur_imm;
                            3'b100: SP <= {cur_imm[15:2], 2'b00};
                            3'b111: FR <= cur_imm;
                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end
            // Roman's part
            
            // Call ret cmp test (Radomyr)

            // CALL [$IMM]
            6'b010010: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[21:6];
                        SP <= SP - 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        if (SP[1]) byte_enable <= 4'b1100;
                        else byte_enable <= 4'b0011;
                        address <= {SP[15:2], 2'b00};
                        write_req <= 1;
                        write_data <= {2{PC}};
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        PC <= cur_imm;
                    end

                    default: begin
                    end
                endcase
            end
            
            // CALL %REG
            6'b010011: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        case (cur_instruction[8:6])
                            3'b000: cur_imm <= R00;
                            3'b001: cur_imm <= R01;
                            3'b010: cur_imm <= R02;
                            3'b011: cur_imm <= R03;

                            default: begin
                            end
                        endcase
                        SP <= SP - 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        if (SP[1]) byte_enable <= 4'b1100;
                        else byte_enable <= 4'b0011;
                        address <= {SP[15:2], 2'b00};
                        write_req <= 1;
                        write_data <= {2{PC}};
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        PC <= cur_imm;
                    end

                    default: begin
                    end
                endcase
            end
            
            // RET
            6'b010100: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        read_req <= 1;
                        address <= {SP[15:2], 2'b00};
                        byte_enable <= 4'b1111;
                        SP <= SP + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        if (SP[1]) cur_imm <= data[15:0];
                        else cur_imm <= data[31:16];
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        PC <= cur_imm;
                    end

                    default: begin
                    end
                endcase
            end
            
            // CMP %REG1, %REG2
            8'b010101: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[8:6];
                        instr_reg_2 <= cur_instruction[11:9];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: cur_imm <= R00;
                            3'b001: cur_imm <= R01;
                            3'b010: cur_imm <= R02;
                            3'b011: cur_imm <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: begin
                                tmp_word <= R00;
                                tmp_address <= R00 - cur_imm;
                            end
                            3'b001: begin
                                tmp_word <= R01;
                                tmp_address <= R01 - cur_imm;
                            end
                            3'b010: begin
                                tmp_word <= R02;
                                tmp_address <= R02 - cur_imm;
                            end
                            3'b011: begin
                                tmp_word <= R03;
                                tmp_address <= R03 - cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end
            
            // CMP %REG1, $IMM
            6'b010110: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[8:6];
                        instr_reg_2 <= cur_instruction[11:9];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                tmp_address <= R00 - cur_imm;
                                tmp_word <= R00;
                            end
                            3'b001: begin
                                tmp_address <= R01 - cur_imm;
                                tmp_word <= R01;
                            end
                            3'b010: begin
                                tmp_address <= R02 - cur_imm;
                                tmp_word <= R02;
                            end
                            3'b011: begin
                                tmp_address <= R03 - cur_imm;
                                tmp_word <= R00;
                            end

                            default: begin
                            end
                        endcase
                        FR <= 16'd0;
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end
            
            // TEST %REG1, %REG2
            6'b010111: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[8:6];
                        instr_reg_2 <= cur_instruction[11:9];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: cur_imm <= R00;
                            3'b001: cur_imm <= R01;
                            3'b010: cur_imm <= R02;
                            3'b011: cur_imm <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: begin
                                tmp_word <= R00;
                                tmp_address <= R00 & cur_imm;
                            end
                            3'b001: begin
                                tmp_word <= R01;
                                tmp_address <= R01 & cur_imm;
                            end
                            3'b010: begin
                                tmp_word <= R02;
                                tmp_address <= R02 & cur_imm;
                            end
                            3'b011: begin
                                tmp_word <= R03;
                                tmp_address <= R03 & cur_imm;
                            end

                            default: begin
                            end
                        endcase
                        FR <= 16'd0;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end
            
            // TEST %REG1, $IMM
            6'b010111: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[8:6];
                        instr_reg_2 <= cur_instruction[11:9];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: begin
                                tmp_word <= R00;
                                tmp_address <= R00 & cur_imm;
                            end
                            3'b001: begin
                                tmp_word <= R01;
                                tmp_address <= R01 & cur_imm;
                            end
                            3'b010: begin
                                tmp_word <= R02;
                                tmp_address <= R02 & cur_imm;
                            end
                            3'b011: begin
                                tmp_word <= R03;
                                tmp_address <= R03 & cur_imm;
                            end

                            default: begin
                            end
                        endcase
                        FR <= 16'd0;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end
            
            // Jumps (Roman)
            
            // IO (Radomyr)
            // IN %REG, $IMM
            6'b100000: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        instr_reg_1 <= cur_instruction[8:6];
                        cur_imm <= cur_instruction[31:16];
                        if (cur_instruction[31:16] == 0) uart_read_req <= 1;
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: R00 <= {8'b00, uart_data};
                            3'b001: R01 <= {8'b00, uart_data};
                            3'b010: R02 <= {8'b00, uart_data};
                            3'b011: R03 <= {8'b00, uart_data};
                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end
            
            // OUT $IMM1, $IMM2
            6'b100001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        if (cur_instruction[21:6] == 0) begin
                            uart_write_req <= 1;
                            uart_wdata <= cur_instruction[29:22];
                        end
                        PC <= PC + 16'd5;
                    end

                    default: begin
                    end
                endcase
            end
            
            // OUT $IMM, %REG
            6'b100010: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        if (cur_instruction[21:6] == 0) begin
                            uart_write_req <= 1;
                            case (cur_instruction[24:22])
                                3'b000: uart_wdata <= R00[7:0];
                                3'b001: uart_wdata <= R01[7:0];
                                3'b010: uart_wdata <= R02[7:0];
                                3'b011: uart_wdata <= R03[7:0];

                                default: begin
                                end
                            endcase
                        end
                        PC <= PC + 16'd4;
                    end

                    default: begin
                    end
                endcase
            end
            
            // END

            // MOV %REG1, [%REG2]
            8'b01100001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: begin
                                address <= {R00[15:2], 2'b00};
                                tmp_address <= R00;
                            end
                            3'b001: begin
                                address <= {R01[15:2], 2'b00};
                                tmp_address <= R01;
                            end
                            3'b010: begin
                                address <= {R02[15:2], 2'b00};
                                tmp_address <= R02;
                            end
                            3'b011: begin
                                address <= {R03[15:2], 2'b00};
                                tmp_address <= R03;
                            end

                            3'b100: begin
                                address <= {SP[15:2], 2'b00};
                                tmp_address <= SP;
                            end

                            3'b101: begin
                                address <= {BP[15:2], 2'b00};
                                tmp_address <= BP;
                            end

                            default: begin
                            end
                        endcase

                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        case (instr_reg_1)
                            3'b000: R00 <= cur_imm;
                            3'b001: R01 <= cur_imm;
                            3'b010: R02 <= cur_imm;
                            3'b011: R03 <= cur_imm;
                            3'b100: SP <= {cur_imm[15:2], 2'b00};
                            3'b101: BP <= {cur_imm[15:2], 2'b00};
                            3'b111: FR <= cur_imm;

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // MOV %REG1, [%REG2+$OFFSET]
            8'b10100000: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_address <= R00 + cur_imm;
                            3'b001: tmp_address <= R01 + cur_imm;
                            3'b010: tmp_address <= R02 + cur_imm;
                            3'b011: tmp_address <= R03 + cur_imm;

                            3'b100: tmp_address <= SP + cur_imm;
                            3'b101: tmp_address <= BP + cur_imm;

                            default: begin
                            end
                        endcase
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        case (tmp_address[1:0])
                            2'b00: tmp_word <= data[15:0];
                            2'b01: tmp_word <= data[23:8];
                            2'b10: tmp_word <= data[31:16];
                            2'b11: begin
                                tmp_word[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        if (tmp_address[1:0] == 2'b11) tmp_word[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_WRITEBACK: begin
                        case (instr_reg_1)
                            3'b000: R00 <= tmp_word;
                            3'b001: R01 <= tmp_word;
                            3'b010: R02 <= tmp_word;
                            3'b011: R03 <= tmp_word;
                            3'b100: SP <= {tmp_word[15:2], 2'b00};
                            3'b101: BP <= {tmp_word[15:2], 2'b00};
                            3'b111: FR <= tmp_word;

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // MOV [%REG1], %REG2
            8'b01100010: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            3'b100: tmp_address <= SP;
                            3'b101: tmp_address <= BP;

                            default: begin
                            end
                        endcase

                        case (instr_reg_2)
                            3'b000: tmp_word <= R00;
                            3'b001: tmp_word <= R01;
                            3'b010: tmp_word <= R02;
                            3'b011: tmp_word <= R03;
                            3'b100: tmp_word <= SP;
                            3'b101: tmp_word <= BP;
                            3'b111: tmp_word <= FR;

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b1100;
                            end

                            2'b01: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b1000;
                            end
                            default: begin
                            end
                        endcase

                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                address <= {tmp_address[15:2], 2'b00};
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0100;
                                write_req <= 1;
                            end

                            2'b11: begin
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0001;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // MOV [%REG1], $IMM
            8'b10000001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        tmp_word <= cur_imm;

                        case (instr_reg_1) 
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            3'b100: tmp_address <= SP;
                            3'b101: tmp_address <= BP;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        address <= {tmp_address[15:2], 2'b00};

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b1100;
                            end

                            2'b01: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b1000;
                            end
                            default: begin
                            end
                        endcase

                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                address <= {tmp_address[15:2], 2'b00};
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0100;
                                write_req <= 1;
                            end

                            2'b11: begin
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0001;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end


                    default: begin
                    end
                endcase
            end

            // MOV [%REG1+$OFFSET], %REG2
            8'b10100001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[34:32];
                        PC <= PC + 16'd5;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        case (instr_reg_2)
                            3'b000: tmp_word <= R00;
                            3'b001: tmp_word <= R01;
                            3'b010: tmp_word <= R02;
                            3'b011: tmp_word <= R03;
                            3'b100: tmp_word <= SP;
                            3'b101: tmp_word <= BP;
                            3'b111: tmp_word <= FR;
                            default: begin
                            end
                        endcase

                        case (instr_reg_1)
                            3'b000: tmp_address <= R00 + cur_imm;
                            3'b001: tmp_address <= R01 + cur_imm;
                            3'b010: tmp_address <= R02 + cur_imm;
                            3'b011: tmp_address <= R03 + cur_imm;
                            3'b100: tmp_address <= SP + cur_imm;
                            3'b101: tmp_address <= BP + cur_imm;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        address <= {tmp_address[15:2], 2'b00};

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b1100;
                            end

                            2'b01: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b1000;
                            end
                            default: begin
                            end
                        endcase

                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                address <= {tmp_address[15:2], 2'b00};
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0100;
                                write_req <= 1;
                            end

                            2'b11: begin
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0001;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // MOV [%REG1+$OFFSET], $IMM
            8'b11000000: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        snd_imm <= cur_instruction[47:32];
                        instr_reg_1 <= cur_instruction[10:8];
                        PC <= PC + 16'd6;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        tmp_word <= snd_imm;

                        case (instr_reg_1)
                            3'b000: tmp_address <= R00 + cur_imm;
                            3'b001: tmp_address <= R01 + cur_imm;
                            3'b010: tmp_address <= R02 + cur_imm;
                            3'b011: tmp_address <= R03 + cur_imm;
                            3'b100: tmp_address <= SP + cur_imm;
                            3'b101: tmp_address <= BP + cur_imm;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        address <= {tmp_address[15:2], 2'b00};

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b1100;
                            end

                            2'b01: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b1000;
                            end
                            default: begin
                            end
                        endcase

                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                address <= {tmp_address[15:2], 2'b00};
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0100;
                                write_req <= 1;
                            end

                            2'b11: begin
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0001;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // PUSH %REG
            8'b00000001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_DECODE: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        PC <= PC + 16'd2;
                        SP <= SP - 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: write_data <= {2{R00}};
                            3'b001: write_data <= {2{R01}};
                            3'b010: write_data <= {2{R02}};
                            3'b011: write_data <= {2{R03}};
                            3'b100: write_data <= {2{SP}};
                            3'b101: write_data <= {2{BP}};
                            3'b111: write_data <= {2{FR}};
                            default: begin
                            end
                        endcase
                        if (SP[1]) byte_enable <= 4'b1100;
                        else byte_enable <= 4'b0011;
                        address <= {SP[15:2], 2'b00};
                        write_req <= '1;
                    end

                    default: begin
                    end
                endcase
            end

            // PUSH $IMM
            8'b01000000: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[23:8];
                        PC <= PC + 16'd3;
                        SP <= SP - 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        write_data <= cur_imm;
                        if (SP[1]) byte_enable <= 4'b1100;
                        else byte_enable <= 4'b0011;
                        address <= {SP[15:2], 2'b00};
                        write_req <= '1;
                    end

                    default: begin
                    end
                endcase
            end

            // POP %REG
            8'b00000010: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {SP[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        if (SP[1]) cur_imm <= data[31:16];
                        else cur_imm <= data[15:0];
                        SP <= SP + 16'd2;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: R00 <= cur_imm;
                            3'b001: R01 <= cur_imm;
                            3'b010: R02 <= cur_imm;
                            3'b011: R03 <= cur_imm;
                            3'b100: SP <= {cur_imm[15:2], 2'b00};
                            3'b101: BP <= {cur_imm[15:2], 2'b00};
                            3'b111: FR <= cur_imm;
                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // ADD %REG1, [%REG2]
            8'b01100011: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 + cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R00 + cur_imm;
                            end
                            3'b001: begin
                                R01 <= R01 + cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R01 + cur_imm;
                            end
                            3'b010: begin
                                R02 <= R02 + cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R02 + cur_imm;
                            end
                            3'b011: begin
                                R03 <= R03 + cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R03 + cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // ADD %REG1, %REG2
            8'b01100100: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: cur_imm <= R00;
                            3'b001: cur_imm <= R01;
                            3'b010: cur_imm <= R02;
                            3'b011: cur_imm <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 + cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R00 + cur_imm;
                            end
                            3'b001: begin
                                R01 <= R01 + cur_imm;
                                tmp_word <= R01;
                                tmp_address <= R01 + cur_imm;
                            end
                            3'b010: begin
                                R02 <= R02 + cur_imm;
                                tmp_word <= R02;
                                tmp_address <= R02 + cur_imm;
                            end
                            3'b011: begin
                                R03 <= R03 + cur_imm;
                                tmp_word <= R03;
                                tmp_address <= R03 + cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end


            // ADD %REG1, [%REG2 + $OFFSET]
            8'b10100010: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_address <= R00 + cur_imm;
                            3'b001: tmp_address <= R01 + cur_imm;
                            3'b010: tmp_address <= R02 + cur_imm;
                            3'b011: tmp_address <= R03 + cur_imm;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 + cur_imm;
                                tmp_address <= R00 + cur_imm;
                                tmp_word <= R00;
                            end
                            3'b001: begin
                                R01 <= R01 + cur_imm;
                                tmp_address <= R01 + cur_imm;
                                tmp_word <= R01;
                            end
                            3'b010: begin
                                R02 <= R02 + cur_imm;
                                tmp_address <= R02 + cur_imm;
                                tmp_word <= R02;
                            end
                            3'b011: begin
                                R03 <= R03 + cur_imm;
                                tmp_address <= R03 + cur_imm;
                                tmp_word <= R00;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // ADD [%REG1], %REG2
            8'b01100101: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;

                        case (cur_instruction[10:8])
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        case (instr_reg_2)
                            3'b000: begin
                                tmp_word <= R00 + cur_imm;
                                snd_imm <= R00;
                            end
                            3'b001: begin
                                tmp_word <= R01 + cur_imm;
                                snd_imm <= R01;
                            end
                            3'b010: begin
                                tmp_word <= R02 + cur_imm;
                                snd_imm <= R02;
                            end
                            3'b011: begin
                                tmp_word <= R03 + cur_imm;
                                snd_imm <= R03;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        address <= {tmp_address[15:2], 2'b00};

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b1100;
                            end

                            2'b01: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b1000;
                            end
                            default: begin
                            end
                        endcase

                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                address <= {tmp_address[15:2], 2'b00};
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0100;
                                write_req <= 1;
                            end

                            2'b11: begin
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0001;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <=  tmp_word < cur_imm;
                        FR[1] <= (
                            (~tmp_word[15] & snd_imm[15] & cur_imm[15]) |
                            (tmp_word[15] & ~snd_imm[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_word[15];
                        FR[3] <= tmp_word == 0;
                    end


                    default: begin
                    end
                endcase
            end

            // SUB %REG1, [%REG2]
            8'b01100110: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 - cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R00 - cur_imm;
                            end
                            3'b001: begin
                                R01 <= R01 - cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R01 - cur_imm;
                            end
                            3'b010: begin
                                R02 <= R02 - cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R02 - cur_imm;
                            end
                            3'b011: begin
                                R03 <= R03 - cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R03 - cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address > tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // SUB %REG1, %REG2
            8'b01100111: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: cur_imm <= R00;
                            3'b001: cur_imm <= R01;
                            3'b010: cur_imm <= R02;
                            3'b011: cur_imm <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 - cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R00 - cur_imm;
                            end
                            3'b001: begin
                                R01 <= R01 - cur_imm;
                                tmp_word <= R01;
                                tmp_address <= R01 - cur_imm;
                            end
                            3'b010: begin
                                R02 <= R02 - cur_imm;
                                tmp_word <= R02;
                                tmp_address <= R02 - cur_imm;
                            end
                            3'b011: begin
                                R03 <= R03 - cur_imm;
                                tmp_word <= R03;
                                tmp_address <= R03 - cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address > tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end


            // SUB %REG1, [%REG2 + $OFFSET]
            8'b10100011: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_address <= R00 + cur_imm;
                            3'b001: tmp_address <= R01 + cur_imm;
                            3'b010: tmp_address <= R02 + cur_imm;
                            3'b011: tmp_address <= R03 + cur_imm;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 - cur_imm;
                                tmp_address <= R00 + cur_imm;
                                tmp_word <= R00;
                            end
                            3'b001: begin
                                R01 <= R01 - cur_imm;
                                tmp_address <= R01 - cur_imm;
                                tmp_word <= R01;
                            end
                            3'b010: begin
                                R02 <= R02 - cur_imm;
                                tmp_address <= R02 - cur_imm;
                                tmp_word <= R02;
                            end
                            3'b011: begin
                                R03 <= R03 - cur_imm;
                                tmp_address <= R03 - cur_imm;
                                tmp_word <= R00;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <= tmp_address > tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // SUB [%REG1], %REG2
            8'b01101000: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;

                        case (cur_instruction[10:8])
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        case (instr_reg_2)
                            3'b000: begin
                                tmp_word <= R00 - cur_imm;
                                snd_imm <= R00;
                            end
                            3'b001: begin
                                tmp_word <= R01 - cur_imm;
                                snd_imm <= R01;
                            end
                            3'b010: begin
                                tmp_word <= R02 - cur_imm;
                                snd_imm <= R02;
                            end
                            3'b011: begin
                                tmp_word <= R03 - cur_imm;
                                snd_imm <= R03;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        address <= {tmp_address[15:2], 2'b00};

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b1100;
                            end

                            2'b01: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b1000;
                            end
                            default: begin
                            end
                        endcase

                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                address <= {tmp_address[15:2], 2'b00};
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0100;
                                write_req <= 1;
                            end

                            2'b11: begin
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0001;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <=  tmp_word > cur_imm;
                        FR[1] <= (
                            (~tmp_word[15] & snd_imm[15] & cur_imm[15]) |
                            (tmp_word[15] & ~snd_imm[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_word[15];
                        FR[3] <= tmp_address == 0;
                    end


                    default: begin
                    end
                endcase
            end

            // INC %REG
            8'b00011111: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 + 16'd1;
                                tmp_word <= R00 + 16'd1;
                                cur_imm <= R00;
                            end
                            3'b001: begin
                                R01 <= R01 + 16'd1;
                                tmp_word <= R01 + 16'd1;
                                cur_imm <= R01;
                            end
                            3'b010: begin
                                R02 <= R02 + 16'd1;
                                tmp_word <= R02 + 16'd1;
                                cur_imm <= R02;
                            end
                            3'b011: begin
                                R03 <= R03 + 16'd1;
                                tmp_word <= R03 + 16'd1;
                                cur_imm <= R03;
                            end
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <=  tmp_word < cur_imm;
                        FR[1] <= (~tmp_word[15] & cur_imm[15]);
                        FR[2] <= tmp_word[15];
                        FR[3] <= |tmp_word;
                    end
                    default: begin
                    end
                endcase
            end

            // INC [%REG1]
            8'b00000100: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;

                        case (cur_instruction[10:8])
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        tmp_word <= cur_imm + 16'd1;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        address <= {tmp_address[15:2], 2'b00};

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b1100;
                            end

                            2'b01: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b1000;
                            end
                            default: begin
                            end
                        endcase

                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                address <= {tmp_address[15:2], 2'b00};
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0100;
                                write_req <= 1;
                            end

                            2'b11: begin
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0001;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <=  tmp_word < cur_imm;
                        FR[1] <= (~tmp_word[15] & cur_imm[15]);
                        FR[2] <= tmp_word[15];
                        FR[3] <= |tmp_word;
                    end


                    default: begin
                    end
                endcase
            end

            // INC [%REG1 + $OFFSET]
            8'b10000010: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: tmp_address <= R00 + cur_imm;
                            3'b001: tmp_address <= R01 + cur_imm;
                            3'b010: tmp_address <= R02 + cur_imm;
                            3'b011: tmp_address <= R03 + cur_imm;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        tmp_address <= tmp_address + snd_imm;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end


                    CPU_STATE_INSTR_EXEC_1: begin
                        tmp_word <= cur_imm + 16'd1;
                    end

                    CPU_STATE_INSTR_WRITEBACK: begin
                        address <= {tmp_address[15:2], 2'b00};

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b1100;
                            end

                            2'b01: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b1000;
                            end
                            default: begin
                            end
                        endcase

                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <=  tmp_word < cur_imm;
                        FR[1] <= (~tmp_word[15] & cur_imm[15]);
                        FR[2] <= tmp_word[15];
                        FR[3] <= |tmp_word;

                        case (tmp_address[1:0])
                            2'b01: begin
                                address <= {tmp_address[15:2], 2'b00};
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0100;
                                write_req <= 1;
                            end

                            2'b11: begin
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0001;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // DEC %REG
            8'b00000101: begin
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 - 16'd1;
                                tmp_word <= R00 - 16'd1;
                                cur_imm <= R00;
                            end
                            3'b001: begin
                                R01 <= R01 - 16'd1;
                                tmp_word <= R01 - 16'd1;
                                cur_imm <= R01;
                            end
                            3'b010: begin
                                R02 <= R02 - 16'd1;
                                tmp_word <= R02 - 16'd1;
                                cur_imm <= R02;
                            end
                            3'b011: begin
                                R03 <= R03 - 16'd1;
                                tmp_word <= R03 - 16'd1;
                                cur_imm <= R03;
                            end
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <=  tmp_word > cur_imm;
                        FR[1] <= (~tmp_word[15] & cur_imm[15]);
                        FR[2] <= tmp_word[15];
                        FR[3] <= |tmp_word;
                    end
            end

            // DEC [%REG1]
            8'b00000110: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;

                        case (cur_instruction[10:8])
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        tmp_word <= cur_imm - 16'd1;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        address <= {tmp_address[15:2], 2'b00};

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b1100;
                            end

                            2'b01: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b1000;
                            end
                            default: begin
                            end
                        endcase

                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                address <= {tmp_address[15:2], 2'b00};
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0100;
                                write_req <= 1;
                            end

                            2'b11: begin
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0001;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <=  tmp_word < cur_imm;
                        FR[1] <= (~tmp_word[15] & cur_imm[15]);
                        FR[2] <= tmp_word[15];
                        FR[3] <= |tmp_word;
                    end


                    default: begin
                    end
                endcase
            end

            // DEC [%REG1 + $OFFSET]
            8'b10000011: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: tmp_address <= R00 + cur_imm;
                            3'b001: tmp_address <= R01 + cur_imm;
                            3'b010: tmp_address <= R02 + cur_imm;
                            3'b011: tmp_address <= R03 + cur_imm;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        tmp_address <= tmp_address + snd_imm;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end


                    CPU_STATE_INSTR_EXEC_1: begin
                        tmp_word <= cur_imm - 16'd1;
                    end

                    CPU_STATE_INSTR_WRITEBACK: begin
                        address <= {tmp_address[15:2], 2'b00};

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b1100;
                            end

                            2'b01: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b1000;
                            end
                            default: begin
                            end
                        endcase

                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <=  tmp_word < cur_imm;
                        FR[1] <= (~tmp_word[15] & cur_imm[15]);
                        FR[2] <= tmp_word[15];
                        FR[3] <= |tmp_word;

                        case (tmp_address[1:0])
                            2'b01: begin
                                address <= {tmp_address[15:2], 2'b00};
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0100;
                                write_req <= 1;
                            end

                            2'b11: begin
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0001;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // MUL %REG1, [%REG2]
            8'b01101010: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;

                        case (cur_instruction[13:11])
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 * cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R00 * cur_imm;
                            end
                            3'b001: begin
                                R01 <= R01 * cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R01 * cur_imm;
                            end
                            3'b010: begin
                                R02 <= R02 * cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R02 * cur_imm;
                            end
                            3'b011: begin
                                R03 <= R03 * cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R03 * cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // MUL %REG1, %REG2
            8'b01101001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;

                        case (cur_instruction[13:11])
                            3'b000: cur_imm <= R00;
                            3'b001: cur_imm <= R01;
                            3'b010: cur_imm <= R02;
                            3'b011: cur_imm <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 * cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R00 * cur_imm;
                            end
                            3'b001: begin
                                R01 <= R01 * cur_imm;
                                tmp_word <= R01;
                                tmp_address <= R01 * cur_imm;
                            end
                            3'b010: begin
                                R02 <= R02 * cur_imm;
                                tmp_word <= R02;
                                tmp_address <= R02 * cur_imm;
                            end
                            3'b011: begin
                                R03 <= R03 * cur_imm;
                                tmp_word <= R03;
                                tmp_address <= R03 * cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // MUL %REG1, $IMM
            8'b10000100: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 * cur_imm;
                                tmp_address <= R00 * cur_imm;
                                tmp_word <= R00;
                            end
                            3'b001: begin
                                R01 <= R01 * cur_imm;
                                tmp_address <= R01 * cur_imm;
                                tmp_word <= R01;
                            end
                            3'b010: begin
                                R02 <= R02 * cur_imm;
                                tmp_address <= R02 * cur_imm;
                                tmp_word <= R02;
                            end
                            3'b011: begin
                                R03 <= R03 * cur_imm;
                                tmp_address <= R03 * cur_imm;
                                tmp_word <= R00;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // MUL %REG1, [%REG2 + $OFFSET]
            8'b10100100: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        tmp_word <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_address <= R00 + tmp_word;
                            3'b001: tmp_address <= R01 + tmp_word;
                            3'b010: tmp_address <= R02 + tmp_word;
                            3'b011: tmp_address <= R03 + tmp_word;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 * cur_imm;
                                tmp_address <= R00 * cur_imm;
                                tmp_word <= R00;
                            end
                            3'b001: begin
                                R01 <= R01 * cur_imm;
                                tmp_address <= R01 * cur_imm;
                                tmp_word <= R01;
                            end
                            3'b010: begin
                                R02 <= R02 * cur_imm;
                                tmp_address <= R02 * cur_imm;
                                tmp_word <= R02;
                            end
                            3'b011: begin
                                R03 <= R03 * cur_imm;
                                tmp_address <= R03 * cur_imm;
                                tmp_word <= R00;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // MUL [%REG1], %REG2
            8'b01101011: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;

                        case (cur_instruction[10:8])
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        case (instr_reg_2)
                            3'b000: begin
                                tmp_word <= R00 * cur_imm;
                                snd_imm <= R00;
                            end
                            3'b001: begin
                                tmp_word <= R01 * cur_imm;
                                snd_imm <= R01;
                            end
                            3'b010: begin
                                tmp_word <= R02 * cur_imm;
                                snd_imm <= R02;
                            end
                            3'b011: begin
                                tmp_word <= R03 * cur_imm;
                                snd_imm <= R03;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        address <= {tmp_address[15:2], 2'b00};

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b1100;
                            end

                            2'b01: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b1000;
                            end
                            default: begin
                            end
                        endcase

                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                address <= {tmp_address[15:2], 2'b00};
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0100;
                                write_req <= 1;
                            end

                            2'b11: begin
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0001;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <=  tmp_word < cur_imm;
                        FR[1] <= (
                            (~tmp_word[15] & snd_imm[15] & cur_imm[15]) |
                            (tmp_word[15] & ~snd_imm[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_word[15];
                        FR[3] <= (|snd_imm) & (|cur_imm);
                    end

                    default: begin
                    end
                endcase
            end

            // DIV %REG1, [%REG2]
            8'b01101101: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;

                        case (cur_instruction[13:11])
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        case (instr_reg_1)
                            3'b000: begin
                                if (cur_imm != 0) begin
                                    R00 <= R00 / cur_imm;
                                    tmp_word <= R00;
                                    tmp_address <= R00 / cur_imm;
                                end else begin
                                    R00 <= 0;
                                    FR[5] <= 1;
                                end
                            end
                            3'b001: begin
                                if (cur_imm != 0) begin
                                    R01 <= R01 / cur_imm;
                                    tmp_word <= R01;
                                    tmp_address <= R01 / cur_imm;
                                end else begin
                                    R01 <= 0;
                                    FR[5] <= 1;
                                end
                            end
                            3'b010: begin
                                if (cur_imm != 0) begin
                                    R02 <= R02 / cur_imm;
                                    tmp_word <= R02;
                                    tmp_address <= R02 / cur_imm;
                                end else begin
                                    R02 <= 0;
                                    FR[5] <= 1;
                                end
                            end
                            3'b011: begin
                                if (cur_imm != 0) begin
                                    R03 <= R03 / cur_imm;
                                    tmp_word <= R03;
                                    tmp_address <= R03 / cur_imm;
                                end else begin
                                    R03 <= 0;
                                    FR[5] <= 1;
                                end
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // DIV %REG1, %REG2
            8'b01101100: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;

                        case (cur_instruction[13:11])
                            3'b000: cur_imm <= R00;
                            3'b001: cur_imm <= R01;
                            3'b010: cur_imm <= R02;
                            3'b011: cur_imm <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: begin
                                if (cur_imm != 0) begin
                                    R00 <= R00 / cur_imm;
                                    tmp_word <= R00;
                                    tmp_address <= R00 / cur_imm;
                                end else begin
                                    R00 <= 0;
                                    FR[5] <= 1;
                                end
                            end
                            3'b001: begin
                                if (cur_imm != 0) begin
                                    R01 <= R01 / cur_imm;
                                    tmp_word <= R01;
                                    tmp_address <= R01 / cur_imm;
                                end else begin
                                    R01 <= 0;
                                    FR[5] <= 1;
                                end
                            end
                            3'b010: begin
                                if (cur_imm != 0) begin
                                    R02 <= R02 / cur_imm;
                                    tmp_word <= R02;
                                    tmp_address <= R02 / cur_imm;
                                end else begin
                                    R02 <= 0;
                                    FR[5] <= 1;
                                end
                            end
                            3'b011: begin
                                if (cur_imm != 0) begin
                                    R03 <= R03 / cur_imm;
                                    tmp_word <= R03;
                                    tmp_address <= R03 / cur_imm;
                                end else begin
                                    R03 <= 0;
                                    FR[5] <= 1;
                                end
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // DIV [%REG1], %REG2
            8'b01101110: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;

                        case (cur_instruction[10:8])
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        case (instr_reg_2)
                            3'b000: begin
                                if (R00 != 0) begin
                                    tmp_word <= cur_imm / R00;
                                    snd_imm <= R00;
                                end else begin
                                    tmp_word <= 0;
                                    FR[1] <= 1;
                                end
                            end
                            3'b001: begin
                                if (R01 != 0) begin
                                    tmp_word <= cur_imm / R01;
                                    snd_imm <= R01;
                                end else begin
                                    tmp_word <= 0;
                                    FR[1] <= 1;
                                end
                            end
                            3'b010: begin
                                if (R02 != 0) begin
                                    tmp_word <= cur_imm / R02;
                                    snd_imm <= R02;
                                end else begin
                                    tmp_word <= 0;
                                    FR[1] <= 1;
                                end
                            end
                            3'b011: begin
                                if (R03 != 0) begin
                                    tmp_word <= cur_imm / R03;
                                    snd_imm <= R03;
                                end else begin
                                    tmp_word <= 0;
                                    FR[1] <= 1;
                                end
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        address <= {tmp_address[15:2], 2'b00};

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b1100;
                            end

                            2'b01: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b1000;
                            end
                            default: begin
                            end
                        endcase

                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                address <= {tmp_address[15:2], 2'b00};
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0100;
                                write_req <= 1;
                            end

                            2'b11: begin
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0001;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <=  tmp_word < cur_imm;
                        FR[1] <= (
                            (~tmp_word[15] & snd_imm[15] & cur_imm[15]) |
                            (tmp_word[15] & ~snd_imm[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_word[15];
                        FR[3] <= (|snd_imm) & (|cur_imm);
                    end

                    default: begin
                    end
                endcase
            end

            // DIV %REG1, $IMM
            8'b10000101: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                if (cur_imm != 0) begin
                                    R00 <= R00 / cur_imm;
                                    tmp_word <= R00;
                                    tmp_address <= R00 / cur_imm;
                                end else begin
                                    R00 <= 0;
                                    FR[5] <= 1;
                                end
                            end
                            3'b001: begin
                                if (cur_imm != 0) begin
                                    R01 <= R01 / cur_imm;
                                    tmp_word <= R01;
                                    tmp_address <= R01 / cur_imm;
                                end else begin
                                    R01 <= 0;
                                    FR[5] <= 1;
                                end
                            end
                            3'b010: begin
                                if (cur_imm != 0) begin
                                    R02 <= R02 / cur_imm;
                                    tmp_word <= R02;
                                    tmp_address <= R02 / cur_imm;
                                end else begin
                                    R02 <= 0;
                                    FR[5] <= 1;
                                end
                            end
                            3'b011: begin
                                if (cur_imm != 0) begin
                                    R03 <= R03 / cur_imm;
                                    tmp_word <= R03;
                                    tmp_address <= R03 / cur_imm;
                                end else begin
                                    R03 <= 0;
                                    FR[5] <= 1;
                                end
                            end
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // DIV %REG1, [%REG2 + $OFFSET]
            8'b10100101: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        tmp_word <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_address <= R00 + tmp_word;
                            3'b001: tmp_address <= R01 + tmp_word;
                            3'b010: tmp_address <= R02 + tmp_word;
                            3'b011: tmp_address <= R03 + tmp_word;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                if (cur_imm != 0) begin
                                    R00 <= R00 / cur_imm;
                                    tmp_word <= R00;
                                    tmp_address <= R00 / cur_imm;
                                end else begin
                                    R00 <= 0;
                                    FR[5] <= 1;
                                end
                            end
                            3'b001: begin
                                if (cur_imm != 0) begin
                                    R01 <= R01 / cur_imm;
                                    tmp_word <= R01;
                                    tmp_address <= R01 / cur_imm;
                                end else begin
                                    R01 <= 0;
                                    FR[5] <= 1;
                                end
                            end
                            3'b010: begin
                                if (cur_imm != 0) begin
                                    R02 <= R02 / cur_imm;
                                    tmp_word <= R02;
                                    tmp_address <= R02 / cur_imm;
                                end else begin
                                    R02 <= 0;
                                    FR[5] <= 1;
                                end
                            end
                            3'b011: begin
                                if (cur_imm != 0) begin
                                    R03 <= R03 / cur_imm;
                                    tmp_word <= R03;
                                    tmp_address <= R03 / cur_imm;
                                end else begin
                                    R03 <= 0;
                                    FR[5] <= 1;
                                end
                            end
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // AND %REG1, [%REG2]
            8'b01110000: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 & cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R00 & cur_imm;
                            end
                            3'b001: begin
                                R01 <= R01 & cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R01 & cur_imm;
                            end
                            3'b010: begin
                                R02 <= R02 & cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R02 & cur_imm;
                            end
                            3'b011: begin
                                R03 <= R03 & cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R03 & cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // AND %REG1, %REG2
            8'b01101111: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: cur_imm <= R00;
                            3'b001: cur_imm <= R01;
                            3'b010: cur_imm <= R02;
                            3'b011: cur_imm <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 & cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R00 & cur_imm;
                            end
                            3'b001: begin
                                R01 <= R01 & cur_imm;
                                tmp_word <= R01;
                                tmp_address <= R01 & cur_imm;
                            end
                            3'b010: begin
                                R02 <= R02 & cur_imm;
                                tmp_word <= R02;
                                tmp_address <= R02 & cur_imm;
                            end
                            3'b011: begin
                                R03 <= R03 & cur_imm;
                                tmp_word <= R03;
                                tmp_address <= R03 & cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // OR %REG1, [%REG2]
            8'b01110010: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 | cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R00 | cur_imm;
                            end
                            3'b001: begin
                                R01 <= R01 | cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R01 | cur_imm;
                            end
                            3'b010: begin
                                R02 <= R02 | cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R02 | cur_imm;
                            end
                            3'b011: begin
                                R03 <= R03 | cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R03 | cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // OR %REG1, %REG2
            8'b01110001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: cur_imm <= R00;
                            3'b001: cur_imm <= R01;
                            3'b010: cur_imm <= R02;
                            3'b011: cur_imm <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 | cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R00 | cur_imm;
                            end
                            3'b001: begin
                                R01 <= R01 | cur_imm;
                                tmp_word <= R01;
                                tmp_address <= R01 | cur_imm;
                            end
                            3'b010: begin
                                R02 <= R02 | cur_imm;
                                tmp_word <= R02;
                                tmp_address <= R02 | cur_imm;
                            end
                            3'b011: begin
                                R03 <= R03 | cur_imm;
                                tmp_word <= R03;
                                tmp_address <= R03 | cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // XOR %REG1, [%REG2]
            8'b01110100: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 ^ cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R00 ^ cur_imm;
                            end
                            3'b001: begin
                                R01 <= R01 ^ cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R01 ^ cur_imm;
                            end
                            3'b010: begin
                                R02 <= R02 ^ cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R02 ^ cur_imm;
                            end
                            3'b011: begin
                                R03 <= R03 ^ cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R03 ^ cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // XOR %REG1, %REG2
            8'b01110011: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: cur_imm <= R00;
                            3'b001: cur_imm <= R01;
                            3'b010: cur_imm <= R02;
                            3'b011: cur_imm <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 ^ cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R00 ^ cur_imm;
                            end
                            3'b001: begin
                                R01 <= R01 ^ cur_imm;
                                tmp_word <= R01;
                                tmp_address <= R01 ^ cur_imm;
                            end
                            3'b010: begin
                                R02 <= R02 ^ cur_imm;
                                tmp_word <= R02;
                                tmp_address <= R02 ^ cur_imm;
                            end
                            3'b011: begin
                                R03 <= R03 ^ cur_imm;
                                tmp_word <= R03;
                                tmp_address <= R03 ^ cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // NOT %REG1
            8'b00000111: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= ~R00;
                                tmp_address <= ~R00;
                                tmp_word <= R00;
                            end
                            3'b001: begin
                                R01 <= ~R01;
                                tmp_address <= ~R01;
                                tmp_word <= R01;
                            end
                            3'b010: begin
                                R02 <= ~R02;
                                tmp_address <= ~R02;
                                tmp_word <= R02;
                            end
                            3'b011: begin
                                R03 <= ~R03;
                                tmp_address <= ~R03;
                                tmp_word <= R03;
                            end
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // NOT [%REG1]
            8'b00001000: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        PC <= PC + 16'd2;

                        case (cur_instruction[10:8])
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        case (instr_reg_2)
                            3'b000: begin
                                tmp_word <= ~cur_imm;
                                snd_imm <= cur_imm;
                            end
                            3'b001: begin
                                tmp_word <= ~cur_imm;
                                snd_imm <= cur_imm;
                            end
                            3'b010: begin
                                tmp_word <= ~cur_imm;
                                snd_imm <= cur_imm;
                            end
                            3'b011: begin
                                tmp_word <= ~cur_imm;
                                snd_imm <= cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        address <= {tmp_address[15:2], 2'b00};

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{tmp_word}};
                                byte_enable <= 4'b1100;
                            end

                            2'b01: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{tmp_word[7:0]}};
                                byte_enable <= 4'b1000;
                            end
                            default: begin
                            end
                        endcase

                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                address <= {tmp_address[15:2], 2'b00};
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0100;
                                write_req <= 1;
                            end

                            2'b11: begin
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                byte_enable <= 4'b0001;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <=  tmp_word < cur_imm;
                        FR[2] <= tmp_word[15];
                        FR[3] <= |tmp_word;
                    end


                    default: begin
                    end
                endcase
            end

            // TODO: Add FR calcs to the sift operations
            // LSH %REG, $IMM
            8'b10000110: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        cur_imm <= cur_instruction[31:16];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 << cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R00 << cur_imm;
                            end

                            3'b001: begin
                                R01 <= R01 << cur_imm;
                                tmp_word <= R01;
                                tmp_address <= R01 << cur_imm;
                            end

                            3'b010: begin
                                R02 <= R02 << cur_imm;
                                tmp_word <= R02;
                                tmp_address <= R02 << cur_imm;
                            end

                            3'b011: begin
                                R03 <= R03 << cur_imm;
                                tmp_word <= R03;
                                tmp_address <= R03 << cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        FR[0] <= tmp_word[15];
                        FR[1] <= tmp_word[15] ^ tmp_address[15];
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // LSH [%REG], $IMM
            8'b10000111: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        snd_imm <= cur_instruction[31:16];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                address <= {R00[15:2], 2'b00};
                                tmp_address <= R00;
                            end

                            3'b001: begin
                                address <= {R01[15:2], 2'b00};
                                tmp_address <= R01;
                            end

                            3'b010: begin
                                address <= {R02[15:2], 2'b00};
                                tmp_address <= R02;
                            end

                            3'b011: begin
                                address <= {R03[15:2], 2'b00};
                                tmp_address <= R03;
                            end


                            default: begin
                            end
                        endcase

                        byte_enable <= 4'b1111;
                        read_req <= 1;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        tmp_word <= cur_imm << snd_imm;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        FR[0] <= cur_imm[15];
                        FR[1] <= tmp_word[15] ^ cur_imm[15];
                        FR[2] <= tmp_word[15];
                        FR[3] <= |tmp_word;
                        case (tmp_address[1:0])
                            2'b00: begin
                                byte_enable <= 4'b0011;
                                write_data <= {2{tmp_word}};
                            end

                            2'b10: begin
                                byte_enable <= 4'b1100;
                                write_data <= {2{tmp_word}};
                            end

                            2'b01: begin
                                byte_enable <= 4'b0010;
                                write_data <= {4{tmp_word[7:0]}};
                            end

                            2'b11: begin
                                byte_enable <= 4'b1000;
                                write_data <= {4{tmp_word[7:0]}};
                            end

                            default: begin
                            end
                        endcase
                        address <= {tmp_address[15:2], 2'b00};
                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                byte_enable <= 4'b0100;
                                address <= {tmp_address[15:2], 2'b00};
                                write_req <= 1;
                                write_data <= {4{tmp_word[15:8]}};
                            end

                            2'b11: begin
                                byte_enable <= 4'b0001;
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // LSH [%REG + $OFFSET], $IMM
            8'b11000001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        snd_imm <= cur_instruction[47:32];
                        PC <= PC + 16'd6;

                        case (cur_instruction[10:8])
                            3'b000: begin
                                tmp_address <= R00 + cur_instruction[31:16];
                            end

                            3'b001: begin
                                tmp_address <= R01 + cur_instruction[31:16];
                            end

                            3'b010: begin
                                tmp_address <= R02 + cur_instruction[31:16];
                            end

                            3'b011: begin
                                tmp_address <= R03 + cur_instruction[31:16];
                            end


                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {tmp_address[15:2], 2'b00};
                        byte_enable <= 4'b1111;
                        read_req <= 1;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        tmp_word <= cur_imm << snd_imm;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        FR[0] <= cur_imm[15];
                        FR[1] <= tmp_word[15] ^ cur_imm[15];
                        FR[2] <= tmp_word[15];
                        FR[3] <= |tmp_word;
                        case (tmp_address[1:0])
                            2'b00: begin
                                byte_enable <= 4'b0011;
                                write_data <= {2{tmp_word}};
                            end

                            2'b10: begin
                                byte_enable <= 4'b1100;
                                write_data <= {2{tmp_word}};
                            end

                            2'b01: begin
                                byte_enable <= 4'b0010;
                                write_data <= {4{tmp_word[7:0]}};
                            end

                            2'b11: begin
                                byte_enable <= 4'b1000;
                                write_data <= {4{tmp_word[7:0]}};
                            end

                            default: begin
                            end
                        endcase
                        address <= {tmp_address[15:2], 2'b00};
                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                byte_enable <= 4'b0100;
                                address <= {tmp_address[15:2], 2'b00};
                                write_req <= 1;
                                write_data <= {4{tmp_word[15:8]}};
                            end

                            2'b11: begin
                                byte_enable <= 4'b0001;
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // RSH %REG, $IMM
            8'b10001000: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        cur_imm <= cur_instruction[31:16];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                R00 <= R00 >> cur_imm;
                                tmp_word <= R00;
                                tmp_address <= R00 >> cur_imm;
                            end

                            3'b001: begin
                                R01 <= R01 >> cur_imm;
                                tmp_word <= R01;
                                tmp_address <= R01 >> cur_imm;
                            end

                            3'b010: begin
                                R02 <= R02 >> cur_imm;
                                tmp_word <= R02;
                                tmp_address <= R02 >> cur_imm;
                            end

                            3'b011: begin
                                R03 <= R03 >> cur_imm;
                                tmp_word <= R03;
                                tmp_address <= R03 >> cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        FR[0] <= tmp_word[15];
                        FR[1] <= tmp_word[15] ^ tmp_address[15];
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // RSH [%REG], $IMM
            8'b10001001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        snd_imm <= cur_instruction[31:16];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                address <= {R00[15:2], 2'b00};
                                tmp_address <= R00;
                            end

                            3'b001: begin
                                address <= {R01[15:2], 2'b00};
                                tmp_address <= R01;
                            end

                            3'b010: begin
                                address <= {R02[15:2], 2'b00};
                                tmp_address <= R02;
                            end

                            3'b011: begin
                                address <= {R03[15:2], 2'b00};
                                tmp_address <= R03;
                            end


                            default: begin
                            end
                        endcase

                        byte_enable <= 4'b1111;
                        read_req <= 1;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        tmp_word <= cur_imm >> snd_imm;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        FR[0] <= cur_imm[15];
                        FR[1] <= tmp_word[15] ^ cur_imm[15];
                        FR[2] <= tmp_word[15];
                        FR[3] <= |tmp_word;
                        case (tmp_address[1:0])
                            2'b00: begin
                                byte_enable <= 4'b0011;
                                write_data <= {2{tmp_word}};
                            end

                            2'b10: begin
                                byte_enable <= 4'b1100;
                                write_data <= {2{tmp_word}};
                            end

                            2'b01: begin
                                byte_enable <= 4'b0010;
                                write_data <= {4{tmp_word[7:0]}};
                            end

                            2'b11: begin
                                byte_enable <= 4'b1000;
                                write_data <= {4{tmp_word[7:0]}};
                            end

                            default: begin
                            end
                        endcase
                        address <= {tmp_address[15:2], 2'b00};
                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                byte_enable <= 4'b0100;
                                address <= {tmp_address[15:2], 2'b00};
                                write_req <= 1;
                                write_data <= {4{tmp_word[15:8]}};
                            end

                            2'b11: begin
                                byte_enable <= 4'b0001;
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // RSH [%REG + $OFFSET], $IMM
            8'b11000010: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        snd_imm <= cur_instruction[47:32];
                        PC <= PC + 16'd6;

                        case (cur_instruction[10:8])
                            3'b000: begin
                                tmp_address <= R00 + cur_instruction[31:16];
                            end

                            3'b001: begin
                                tmp_address <= R01 + cur_instruction[31:16];
                            end

                            3'b010: begin
                                tmp_address <= R02 + cur_instruction[31:16];
                            end

                            3'b011: begin
                                tmp_address <= R03 + cur_instruction[31:16];
                            end


                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {tmp_address[15:2], 2'b00};
                        byte_enable <= 4'b1111;
                        read_req <= 1;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        tmp_word <= cur_imm >> snd_imm;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        FR[0] <= cur_imm[15];
                        FR[1] <= tmp_word[15] ^ cur_imm[15];
                        FR[2] <= tmp_word[15];
                        FR[3] <= |tmp_word;
                        case (tmp_address[1:0])
                            2'b00: begin
                                byte_enable <= 4'b0011;
                                write_data <= {2{tmp_word}};
                            end

                            2'b10: begin
                                byte_enable <= 4'b1100;
                                write_data <= {2{tmp_word}};
                            end

                            2'b01: begin
                                byte_enable <= 4'b0010;
                                write_data <= {4{tmp_word[7:0]}};
                            end

                            2'b11: begin
                                byte_enable <= 4'b1000;
                                write_data <= {4{tmp_word[7:0]}};
                            end

                            default: begin
                            end
                        endcase
                        address <= {tmp_address[15:2], 2'b00};
                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                byte_enable <= 4'b0100;
                                address <= {tmp_address[15:2], 2'b00};
                                write_req <= 1;
                                write_data <= {4{tmp_word[15:8]}};
                            end

                            2'b11: begin
                                byte_enable <= 4'b0001;
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_data <= {4{tmp_word[15:8]}};
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // CALL LABEL
            8'b01000010: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[23:8];
                        SP <= SP - 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        if (SP[1]) byte_enable <= 4'b1100;
                        else byte_enable <= 4'b0011;
                        address <= {SP[15:2], 2'b00};
                        write_req <= 1;
                        write_data <= {2{PC}};
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        PC <= cur_imm;
                    end

                    default: begin
                    end
                endcase
            end

            // CALL %REG
            8'b00001001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        case (cur_instruction[10:8])
                            3'b000: cur_imm <= R00;
                            3'b001: cur_imm <= R01;
                            3'b010: cur_imm <= R02;
                            3'b011: cur_imm <= R03;

                            default: begin
                            end
                        endcase
                        SP <= SP - 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        if (SP[1]) byte_enable <= 4'b1100;
                        else byte_enable <= 4'b0011;
                        address <= {SP[15:2], 2'b00};
                        write_req <= 1;
                        write_data <= {2{PC}};
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        PC <= cur_imm;
                    end

                    default: begin
                    end
                endcase
            end

            // CALL %REG + $OFFSET
            8'b10001010: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        case (cur_instruction[10:8])
                            3'b000: cur_imm <= R00 + cur_instruction[31:16];
                            3'b001: cur_imm <= R01 + cur_instruction[31:16];
                            3'b010: cur_imm <= R02 + cur_instruction[31:16];
                            3'b011: cur_imm <= R03 + cur_instruction[31:16];

                            default: begin
                            end
                        endcase
                        SP <= SP - 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        if (SP[1]) byte_enable <= 4'b1100;
                        else byte_enable <= 4'b0011;
                        address <= {SP[15:2], 2'b00};
                        write_req <= 1;
                        write_data <= {2{PC}};
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        PC <= cur_imm;
                    end

                    default: begin
                    end
                endcase
            end

            // RET
            8'b00100001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        read_req <= 1;
                        address <= {SP[15:2], 2'b00};
                        byte_enable <= 4'b1111;
                        SP <= SP + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        if (SP[1]) cur_imm <= data[15:0];
                        else cur_imm <= data[31:16];
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        PC <= cur_imm;
                    end

                    default: begin
                    end
                endcase
            end

            // CMP %REG1, [%REG2]
            8'b01110110: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                tmp_word <= R00;
                                tmp_address <= R00 - cur_imm;
                            end
                            3'b001: begin
                                tmp_word <= R00;
                                tmp_address <= R01 - cur_imm;
                            end
                            3'b010: begin
                                tmp_word <= R00;
                                tmp_address <= R02 - cur_imm;
                            end
                            3'b011: begin
                                tmp_word <= R00;
                                tmp_address <= R03 - cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // CMP %REG1, %REG2
            8'b01110101: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: cur_imm <= R00;
                            3'b001: cur_imm <= R01;
                            3'b010: cur_imm <= R02;
                            3'b011: cur_imm <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: begin
                                tmp_word <= R00;
                                tmp_address <= R00 - cur_imm;
                            end
                            3'b001: begin
                                tmp_word <= R01;
                                tmp_address <= R01 - cur_imm;
                            end
                            3'b010: begin
                                tmp_word <= R02;
                                tmp_address <= R02 - cur_imm;
                            end
                            3'b011: begin
                                tmp_word <= R03;
                                tmp_address <= R03 - cur_imm;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // CMP %REG1, [%REG2 + $OFFSET]
            8'b10100110: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_address <= R00 + cur_imm;
                            3'b001: tmp_address <= R01 + cur_imm;
                            3'b010: tmp_address <= R02 + cur_imm;
                            3'b011: tmp_address <= R03 + cur_imm;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                tmp_address <= R00 - cur_imm;
                                tmp_word <= R00;
                            end
                            3'b001: begin
                                tmp_address <= R01 - cur_imm;
                                tmp_word <= R01;
                            end
                            3'b010: begin
                                tmp_address <= R02 - cur_imm;
                                tmp_word <= R02;
                            end
                            3'b011: begin
                                tmp_address <= R03 - cur_imm;
                                tmp_word <= R00;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // CMP %REG1, $IMM
            8'b10001011: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                tmp_address <= R00 - cur_imm;
                                tmp_word <= R00;
                            end
                            3'b001: begin
                                tmp_address <= R01 - cur_imm;
                                tmp_word <= R01;
                            end
                            3'b010: begin
                                tmp_address <= R02 - cur_imm;
                                tmp_word <= R02;
                            end
                            3'b011: begin
                                tmp_address <= R03 - cur_imm;
                                tmp_word <= R00;
                            end

                            default: begin
                            end
                        endcase
                        FR <= 16'd0;
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // TEST %REG1, [%REG2]
            8'b01111000: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                tmp_word <= R00;
                                tmp_address <= R00 & cur_imm;
                            end
                            3'b001: begin
                                tmp_word <= R00;
                                tmp_address <= R01 & cur_imm;
                            end
                            3'b010: begin
                                tmp_word <= R00;
                                tmp_address <= R02 & cur_imm;
                            end
                            3'b011: begin
                                tmp_word <= R00;
                                tmp_address <= R03 & cur_imm;
                            end

                            default: begin
                            end
                        endcase
                        FR <= 16'd0;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // TEST %REG1, %REG2
            8'b01110111: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: cur_imm <= R00;
                            3'b001: cur_imm <= R01;
                            3'b010: cur_imm <= R02;
                            3'b011: cur_imm <= R03;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (instr_reg_1)
                            3'b000: begin
                                tmp_word <= R00;
                                tmp_address <= R00 & cur_imm;
                            end
                            3'b001: begin
                                tmp_word <= R01;
                                tmp_address <= R01 & cur_imm;
                            end
                            3'b010: begin
                                tmp_word <= R02;
                                tmp_address <= R02 & cur_imm;
                            end
                            3'b011: begin
                                tmp_word <= R03;
                                tmp_address <= R03 & cur_imm;
                            end

                            default: begin
                            end
                        endcase
                        FR <= 16'd0;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // TEST %REG1, [%REG2 + $OFFSET]
            8'b10100111: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        cur_imm <= cur_instruction[31:16];
                        instr_reg_1 <= cur_instruction[10:8];
                        instr_reg_2 <= cur_instruction[13:11];
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (instr_reg_2)
                            3'b000: tmp_address <= R00 + cur_imm;
                            3'b001: tmp_address <= R01 + cur_imm;
                            3'b010: tmp_address <= R02 + cur_imm;
                            3'b011: tmp_address <= R03 + cur_imm;
                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        address <= {tmp_address[15:2], 2'b00};
                        read_req <= 1;
                        byte_enable <= 4'b1111;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: cur_imm <= data[15:0];
                            2'b01: cur_imm <= data[23:8];
                            2'b10: cur_imm <= data[31:16];
                            2'b11: begin
                                cur_imm[7:0] <= data[31:24];
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                read_req <= 1;
                                byte_enable <= 4'b1111;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        if (tmp_address[1:0] == 2'b11) cur_imm[15:8] <= data[7:0];
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (instr_reg_1)
                            3'b000: begin
                                tmp_address <= R00 & cur_imm;
                                tmp_word <= R00;
                            end
                            3'b001: begin
                                tmp_address <= R01 & cur_imm;
                                tmp_word <= R01;
                            end
                            3'b010: begin
                                tmp_address <= R02 & cur_imm;
                                tmp_word <= R02;
                            end
                            3'b011: begin
                                tmp_address <= R03 & cur_imm;
                                tmp_word <= R00;
                            end

                            default: begin
                            end
                        endcase
                        FR <= 16'd0;
                    end

                    CPU_STATE_INSTR_WRITEBACK_1: begin
                        FR[0] <= tmp_address < tmp_word;
                        FR[1] <= (
                            (~tmp_address[15] & tmp_word[15] & cur_imm[15]) |
                            (tmp_address[15] & ~tmp_word[15] & ~cur_imm[15])
                        );
                        FR[2] <= tmp_address[15];
                        FR[3] <= tmp_address == 0;
                    end

                    default: begin
                    end
                endcase
            end

            // JMP $IMM
            8'b01000011: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        PC <= cur_instruction[23:8];
                    end

                    default: begin
                    end
                endcase
            end

            // JMP %REG
            8'b00001010: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        case (cur_instruction[10:8])
                            3'b000: cur_imm <= R00;
                            3'b001: cur_imm <= R01;
                            3'b010: cur_imm <= R02;
                            3'b011: cur_imm <= R03;

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        PC <= cur_imm;
                    end

                    default: begin
                    end
                endcase
            end

            // JMP %REG + $OFFSET
            8'b10001100: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        case (cur_instruction[10:8])
                            3'b000: cur_imm <= R00 + cur_instruction[31:16];
                            3'b001: cur_imm <= R01 + cur_instruction[31:16];
                            3'b010: cur_imm <= R02 + cur_instruction[31:16];
                            3'b011: cur_imm <= R03 + cur_instruction[31:16];

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        PC <= cur_imm;
                    end

                    default: begin
                    end
                endcase
            end

            // JE $IMM
            8'b01000100: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        if (FR[3]) PC <= cur_instruction[23:8];
                        else PC <= PC;
                    end

                    default: begin
                    end
                endcase
            end

            // JNE $IMM
            8'b01000101: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        if (~FR[3]) PC <= cur_instruction[23:8];
                        else PC <= PC;
                    end

                    default: begin
                    end
                endcase
            end

            // JG $IMM
            8'b01000110: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        if (~FR[3] & ~FR[1]) PC <= cur_instruction[23:8];
                        else PC <= PC;
                    end

                    default: begin
                    end
                endcase
            end

            // JGE $IMM
            8'b01000111: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        if (~FR[0]) PC <= cur_instruction[23:8];
                        else PC <= PC;
                    end

                    default: begin
                    end
                endcase
            end

            // JL $IMM
            8'b01001000: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        if (FR[1] != FR[2]) PC <= cur_instruction[23:8];
                        else PC <= PC;
                    end

                    default: begin
                    end
                endcase
            end

            // JLE $IMM
            8'b01001001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        if (FR[0] | FR[3]) PC <= cur_instruction[23:8];
                        else PC <= PC;
                    end

                    default: begin
                    end
                endcase
            end

            // IN %REG, $PORT
            8'b10001101: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        instr_reg_1 <= cur_instruction[10:8];
                        cur_imm <= cur_instruction[31:16];
                        if (cur_instruction[31:16] == 0) uart_read_req <= 1;
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        case (instr_reg_1)
                            3'b000: R00 <= {8'b00, uart_data};
                            3'b001: R01 <= {8'b00, uart_data};
                            3'b010: R02 <= {8'b00, uart_data};
                            3'b011: R03 <= {8'b00, uart_data};
                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // IN [%REG], $PORT
            8'b10001110: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        case (cur_instruction[10:8])
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;
                            default: begin
                            end
                        endcase

                        if (cur_instruction[31:16] == 0) uart_read_req <= 1;
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        cur_imm <= {8'd0, uart_data};
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        address <= {tmp_address[15:2], 2'b00};
                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{cur_imm}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{cur_imm}};
                                byte_enable <= 4'b11;
                            end

                            2'b01: begin
                                write_data <= {4{cur_imm[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{cur_imm[7:0]}};
                                byte_enable <= 4'b1000;
                            end

                            default: begin
                            end
                        endcase
                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                write_data <= {4{cur_imm[15:8]}};
                                byte_enable <= 4'b0010;
                                address <= {tmp_address[15:2], 2'b00};
                                write_req <= 1;
                            end

                            2'b11: begin
                                write_data <= {4{cur_imm[15:8]}};
                                byte_enable <= 4'b0001;
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // IN [%REG], $PORT
            8'b11000011: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_OPERAND_FETCH: begin
                        case (cur_instruction[10:8])
                            3'b000: tmp_address <= R00 + cur_instruction[47:32];
                            3'b001: tmp_address <= R01 + cur_instruction[47:32];
                            3'b010: tmp_address <= R02 + cur_instruction[47:32];
                            3'b011: tmp_address <= R03 + cur_instruction[47:32];
                            default: begin
                            end
                        endcase

                        if (cur_instruction[31:16] == 0) uart_read_req <= 1;
                        PC <= PC + 16'd6;
                    end

                    CPU_STATE_INSTR_OPERAND_FETCH_1: begin
                        cur_imm <= {8'd0, uart_data};
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        address <= {tmp_address[15:2], 2'b00};
                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {2{cur_imm}};
                                byte_enable <= 4'b0011;
                            end

                            2'b10: begin
                                write_data <= {2{cur_imm}};
                                byte_enable <= 4'b11;
                            end

                            2'b01: begin
                                write_data <= {4{cur_imm[7:0]}};
                                byte_enable <= 4'b0010;
                            end

                            2'b11: begin
                                write_data <= {4{cur_imm[7:0]}};
                                byte_enable <= 4'b1000;
                            end

                            default: begin
                            end
                        endcase
                        write_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                write_data <= {4{cur_imm[15:8]}};
                                byte_enable <= 4'b0010;
                                address <= {tmp_address[15:2], 2'b00};
                                write_req <= 1;
                            end

                            2'b11: begin
                                write_data <= {4{cur_imm[15:8]}};
                                byte_enable <= 4'b0001;
                                address <= {tmp_address[15:2], 2'b00} + 16'd4;
                                write_req <= 1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    default: begin
                    end
                endcase
            end

            // OUT $PORT, $IMM
            8'b11001111: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        if (cur_instruction[23:8] == 0) begin
                            uart_write_req <= 1;
                            uart_wdata <= cur_instruction[31:24];
                        end
                        PC <= PC + 16'd5;
                    end

                    default: begin
                    end
                endcase
            end

            // OUT $PORT, %REG
            8'b10001111: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        if (cur_instruction[23:8] == 0) begin
                            uart_write_req <= 1;
                            case (cur_instruction[26:24])
                                3'b000: uart_wdata <= R00[7:0];
                                3'b001: uart_wdata <= R01[7:0];
                                3'b010: uart_wdata <= R02[7:0];
                                3'b011: uart_wdata <= R03[7:0];

                                default: begin
                                end
                            endcase
                        end
                        PC <= PC + 16'd4;
                    end

                    default: begin
                    end
                endcase
            end

            // OUT $PORT, [%REG]
            8'b10010000: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        case (cur_instruction[26:24])
                            3'b000: tmp_address <= R00;
                            3'b001: tmp_address <= R01;
                            3'b010: tmp_address <= R02;
                            3'b011: tmp_address <= R03;

                            default: begin
                            end
                        endcase
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {tmp_address[15:2], 2'b00};
                        byte_enable <= 4'b1111;
                        read_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        if (cur_instruction[23:8] == 0) begin
                            uart_write_req <= 1;
                            case (tmp_address[1:0])
                                2'b00: uart_wdata <= data[7:0];
                                2'b01: uart_wdata <= data[15:8];
                                2'b10: uart_wdata <= data[23:16];
                                2'b11: uart_wdata <= data[31:24];
                                default: begin
                                end
                            endcase
                        end
                    end

                    default: begin
                    end
                endcase
            end

            // OUT $PORT, [%REG + $OFFSET]
            8'b11000100: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        case (cur_instruction[26:24])
                            3'b000: tmp_address <= R00 + cur_instruction[47:32];
                            3'b001: tmp_address <= R01 + cur_instruction[47:32];
                            3'b010: tmp_address <= R02 + cur_instruction[47:32];
                            3'b011: tmp_address <= R03 + cur_instruction[47:32];

                            default: begin
                            end
                        endcase
                        PC <= PC + 16'd4;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {tmp_address[15:2], 2'b00};
                        byte_enable <= 4'b1111;
                        read_req <= 1;
                    end

                    CPU_STATE_INSTR_EXEC: begin
                        if (cur_instruction[23:8] == 0) begin
                            uart_write_req <= 1;
                            case (tmp_address[1:0])
                                2'b00: uart_wdata <= data[7:0];
                                2'b01: uart_wdata <= data[15:8];
                                2'b10: uart_wdata <= data[23:16];
                                2'b11: uart_wdata <= data[31:24];
                                default: begin
                                end
                            endcase
                        end
                    end

                    default: begin
                    end
                endcase
            end

            // STORE4 $ADDR
            8'b00001100: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        PC <= PC + 16'd3;
                        tmp_address <= cur_instruction[23:8];
                        address <= {cur_instruction[23:10], 2'b00};
                        write_req <='1;

                        case (cur_instruction[9:8])
                            2'b00: begin
                                write_data <= {R00, R01};
                                byte_enable <= 4'b1111;
                            end

                            2'b01: begin
                                write_data <= {8'b0, R00, R01[7:0]};
                                byte_enable <= 4'b0010;
                            end

                            2'b10: begin
                                write_data <= {2{R00}};
                                byte_enable <= 4'b1100;
                            end

                            2'b11: begin
                                write_data <= {4{R00[7:0]}};
                                byte_enable <= 4'b1000;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        write_req <='1;

                        case (tmp_address[1:0])
                            2'b00: begin
                                write_data <= {R02, R03};
                                byte_enable <= 4'b1111;
                                address <= {cur_instruction[23:10], 2'b00} + 16'd4;
                            end

                            2'b01: begin
                                write_data <= {8'b0, R00, R01[7:0]};
                                byte_enable <= 4'b0011;
                                address <= {cur_instruction[23:10], 2'b00};
                            end

                            2'b10: begin
                                write_data <= {R01, R02};
                                byte_enable <= 4'b1111;
                                address <= {cur_instruction[23:10], 2'b00} + 16'd4;
                            end

                            2'b11: begin
                                write_data <= {R00[15:8], R01, R02[7:0]};
                                byte_enable <= 4'b1111;
                                address <= {cur_instruction[23:10], 2'b00} + 16'd4;
                            end

                            default: begin
                            end
                        endcase

                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                write_data <= {R01[15:8], R02, R03[7:0]};
                                byte_enable <= 4'b1111;
                                address <= {cur_instruction[23:10], 2'b00} + 16'd4;
                                write_req <='1;
                            end

                            2'b10: begin
                                write_data <= {2{R03}};
                                byte_enable <= 4'b1100;
                                address <= {cur_instruction[23:10], 2'b00} + 16'd8;
                                write_req <='1;
                            end

                            2'b11: begin
                                write_data <= {R02[15:8], R03, 8'b0};
                                address <= {cur_instruction[23:10], 2'b00} + 16'd8;
                                byte_enable <= 4'b0011;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                write_data <= {4{R03[15:8]}};
                                byte_enable <= 4'b0001;
                                address <= {cur_instruction[23:10], 2'b00} + 16'd8;
                                write_req <='1;
                            end

                            2'b11: begin
                                write_data <= {R02[15:8], R03, 8'b0};
                                address <= {cur_instruction[23:10], 2'b00} + 16'd8;
                                byte_enable <= 4'b0100;
                            end

                            default: begin
                            end
                        endcase

                    end

                    default: begin
                    end
                endcase
            end

            // LOAD4 $ADDR
            8'b00001011: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        PC <= PC + 16'd3;
                        tmp_address <= cur_instruction[23:8];
                        address <= {cur_instruction[23:10], 2'b00};
                        byte_enable <= 4'b1111;
                        read_req <= '1;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b00: begin
                                R00 <= data[15:0];
                                R01 <= data[31:16];
                            end

                            2'b01: begin
                                R00 <= data[23:8];
                                R01[7:0] <= data[31:24];
                            end

                            2'b10: begin
                                R00 <= data[31:16];
                            end

                            2'b11: begin
                                R00[7:0] <= data[31:24];
                            end

                            default: begin
                            end
                        endcase

                        address <= {cur_instruction[23:10], 2'b00} + 16'd4;
                        byte_enable <= 4'b1111;
                        read_req <= '1;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (tmp_address[1:0])
                            2'b00: begin
                                R02 <= data[15:0];
                                R03 <= data[31:16];
                            end

                            2'b01: begin
                                R01[15:8] <= data[7:0];
                                R02 <= data[23:8];
                                R03[7:0] <= data[31:24];

                                address <= {cur_instruction[23:10], 2'b00} + 16'd8;
                                byte_enable <= 4'b1111;
                                read_req <= '1;
                            end

                            2'b10: begin
                                R01 <= data[15:0];
                                R02 <= data[31:16];

                                address <= {cur_instruction[23:10], 2'b00} + 16'd8;
                                byte_enable <= 4'b1111;
                                read_req <= '1;
                            end

                            2'b11: begin
                                R00[15:8] <= data[7:0];
                                R01 <= data[23:8];
                                R02[7:0] <= data[31:24];

                                address <= {cur_instruction[23:10], 2'b00} + 16'd8;
                                byte_enable <= 4'b1111;
                                read_req <= '1;
                            end

                            default: begin
                            end
                        endcase
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH_1: begin
                        case (tmp_address[1:0])
                            2'b01: begin
                                R03[15:8] <= data[7:0];
                            end

                            2'b10: begin
                                R03 <= data[15:0];
                            end

                            2'b11: begin
                                R02[15:8] <= data[7:0];
                                R03 <= data[23:8];
                            end

                            default: begin
                            end
                        endcase
                    end


                    default: begin
                    end
                endcase
            end

            // ADD4
            8'b01111010: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        PC <= PC + 16'd3;
                        R00[7:0] <= R00[7:0] + R02[7:0];
                        R00[15:8] <= R00[15:8] + R02[15:8];

                        R01[7:0] <= R01[7:0] + R03[7:0];
                        R01[15:8] <= R01[15:8] + R03[15:8];
                        end
                endcase
            end

            // SUB4
            8'b01111011: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        PC <= PC + 16'd3;
                        R00[7:0] <= R00[7:0] - R02[7:0];
                        R00[15:8] <= R00[15:8] - R02[15:8];

                        R01[7:0] <= R01[7:0] - R03[7:0];
                        R01[15:8] <= R01[15:8] - R03[15:8];
                        end
                endcase
            end

            // MUL4
            8'b01111101: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        PC <= PC + 16'd3;
                        R00[7:0] <= R00[7:0] * R02[7:0];
                        R00[15:8] <= R00[15:8] * R02[15:8];

                        R01[7:0] <= R01[7:0] * R03[7:0];
                        R01[15:8] <= R01[15:8] * R03[15:8];
                        end
                endcase
            end

            // DIV4
            8'b01111111: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        PC <= PC + 16'd3;
                        if (!R02[7:0]) R00[7:0] <= R00[7:0] / R02[7:0];
                        else R00[7:0] <= 0;

                        if (!R02[15:8]) R00[15:8] <= R00[15:8] / R02[15:8];
                        else R00[7:0] <= 0;

                        if (!R03[7:0]) R01[7:0] <= R01[7:0] / R03[7:0];
                        else R01[7:0] <= 0;

                        if (!R03[15:8]) R01[15:8] <= R01[15:8] / R03[15:8];
                        else R01[7:0] <= 0;
                        end
                endcase
            end

            // ENTER $IMM
            8'b01000001: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        PC <= PC + 16'd3;
                        SP <= SP - 16'd2;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        write_data <= {2{BP}};
                        address <= {SP[15:2], 2'b00};
                        write_req <= 1;

                        if (SP[1]) byte_enable <= 4'b1100;
                        else byte_enable <= 4'b0011;

                        SP <= BP - {cur_instruction[23:10], 2'b00};
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        FR[0] <= SP > BP;
                        FR[1] <= (
                            (~SP[15] & BP[15] & cur_instruction[23]) |
                            (SP[15] & ~BP[15] & ~cur_instruction[23])
                        );
                        FR[2] <= SP[15];
                        FR[3] <= SP == 0;
                    end


                    default: begin
                    end
                endcase
            end

            // LEAVE
            8'b00100000: begin
                case (cur_cpu_state)
                    CPU_STATE_INSTR_IMM_FETCH: begin
                        PC <= PC + 16'd3;
                        SP <= BP;
                    end

                    CPU_STATE_INSTR_IMM_FETCH_1: begin
                        address <= {SP[15:2], 2'b00};
                        read_req <= 1;
                    end

                    CPU_STATE_INSTR_SECOND_IMM_FETCH: begin
                        case (SP[1:0])
                            2'b00: BP <= {data[15:2], 2'b00};
                            2'b10: BP <= {data[31:18], 2'b00};

                            default: begin
                            end
                        endcase
                    end


                    default: begin
                    end
                endcase
            end

        endcase
    end
end
end
end

endmodule
